# Milestone Log

## 2026-02-11

1. Projektstruktur gescannt (`README`, `README.mcp`, `scripts`, `src/mcp`, Docker/Compose).
2. Laufzeitarchitektur nachvollzogen: klassischer Toolhub-Container (`start.sh`, Flask/Gunicorn, `audio-split.sh`) plus separater TypeScript-MCP-Server.
3. Sicherheits- und Guardrail-Mechanik identifiziert (`SAFE_MODE`, Host-/Path-Allowlist, Rate-Limit, Output-Truncation).
4. Dokumentation und Implementierung gegengeprüft; Abweichungen für Review notiert (z. B. Request-Format bei `/audio-split`).
5. Ergebnisbericht vorbereitet mit aktuellem Stand, Komponentenrollen und offenen Risiken.
6. Dokumentation auf Ist-Verhalten der Flask-API angepasst (`README.md`, `docs/audio-split.md`): JSON-Request/JSON-Response, Endpoint-Übersicht ohne `/run`.
7. Projektziel und Reifegradanalyse durchgeführt: n8n-sidecar Nutzen, verfügbare Tool-Klassen, sowie nicht-funktionale/inkonsistente Bereiche (MCP-Tooling, Cron-Job, Dockerfile-Buildrisiken) identifiziert.

8. Merge-Konflikt in `src/mcp/tool-registry.ts` aufgelöst (vollständige Integration der `docx-template-fill`-Registry inkl. Manifest-Tool-Loader, fehlender Imports/Typen, Konfliktmarker entfernt, Datei wieder im normalen Modus gestaged).
9. PR-Merge-Konflikte beim Aktualisieren von `eric/audit-project-and-create-plan` mit `origin/main` gelöst (`CHANGELOG.md`, `src/mcp/tool-registry.ts`), Konfliktmarker entfernt und Branch für Commit vorbereitet.
10. Re-Scan auf nicht-funktionale Features durchgeführt (inkl. Verifikation per `py_compile`): Integrationslücken zwischen Webhook/MCP/Docker/Docs identifiziert und priorisierter Implementierungsplan mit Abnahmekriterien erstellt.
11. Phase 1 umgesetzt: `docx-template-fill` Syntaxfehler behoben, Cron-Aufruf auf aktuelle `audio-split.sh`-Flags migriert, Dockerfile-`fd`-Symlink robust gemacht und `docs/audio-split.md` auf JSON-API/JSON-Response korrigiert.
12. Phase 2 umgesetzt: MCP-Sidecar auf Toolhub-basierte Runtime mit Node/npm umgestellt (`Dockerfile.mcp` + `docker-compose.mcp.yml`), Build-Befehl auf vollständige Dependency-Installation korrigiert und Laufzeit-Allowlist/Volumes für reale Tool-Ausführung erweitert.
13. Phase 3 umgesetzt (Option B): Webhook `/run` erweitert um manifestbasierte CLI-Tools (`tool.json`), inklusive `args`- und `payload`-Support, Tool-Discovery beim Start und strukturierter CLI-Fehler-/Ergebnisrückgabe. README auf neue `/run`-Fähigkeiten und Env-Variablen aktualisiert.
14. Phase 4 umgesetzt: CI-Workflow für MCP-Build und Python-Tests ergänzt (`.github/workflows/ci.yml`), Release-Workflow auf GHCR vereinheitlicht (`docker-release.yml`) und README auf neue Release-/Webhook- und Env-Realität harmonisiert.
15. Vollständige Multi-Interface-Integration nachgezogen: `/run`-Script-Dispatch serialisiert verschachtelte Payload-Objekte (JSON), `docx-template-fill` in Python-Registry aufgenommen und Wrapper (`docx-render.py`, `docx-template-fill.py`) um direkte Flag-basierte Aufrufe erweitert, sodass SSH/Webhook/MCP dasselbe Toolset nutzen können.
16. MCP-Ergonomie und Discoverability verbessert: MCP-Metadatenblöcke für `audio-split.sh`, `transcript.py`, `cleanup.py`, `docx-render.py`, `docx-template-fill.py` und `wol-cli.sh` ergänzt; dadurch strukturierte Input-Schemas statt reiner `args`-Listen in MCP-Clients.
17. Container-Laufzeit gehärtet: Python-Toolmodule (`tools/`, `mcp_tools/`) werden ins Image nach `/opt/toolhub` kopiert, `TOOLHUB_PYTHON_ROOT` darauf standardisiert und Wrapper/Webhook mit Fallback auf `/workspace` versehen, damit Features auch ohne vollständigen Repo-Bind-Mount funktionsfähig bleiben.
18. E2E-Fixes aus Containerlauf: Leserechte auf `/opt/toolhub` explizit gesetzt, `netbase` für stabile `wakeonlan`-Ausführung ergänzt, `wol-cli`-Wrapper auf mehrere Runtime-Pfade robust gemacht und Start-Initialisierung um schreibbare DOCX-Verzeichnisse (`/templates`, `/output`, `/data/...`) erweitert.
19. Feature-Contract-Dokumentation ergänzt (`docs/features.md`): vollständige Matrix der verfügbaren Features pro Interface (SSH/Webhook/MCP), inklusive konkreter Aufrufbeispiele und Markierung optionaler/binär-abhängiger MCP-Tools.
20. Portainer-Deployment-Artefakt ergänzt (`toolhub.yaml`): einheitlicher Stack mit robusten Default-Variablen, Healthcheck, persistenten Volumes und stack-lokalem Netzwerk, damit Toolhub ohne zusätzlichen Compose-Merge direkt deploybar ist.
21. `toolhub.yaml` auf bestehende Netzwerkinfrastruktur angepasst: externes `allmydocker-net` verwendet und feste Container-IP `192.168.123.5` für den `toolhub`-Service gesetzt.
22. Portainer-Env-Setup erweitert: `toolhub.env` mit vollständigen Stack-/Runtime-Variablen erstellt und `toolhub.yaml` auf BASEDIR-basierten Volume-Pfadaufbau (`/volume2/docker`) umgestellt, inklusive variabler Netzwerk-/IP-Parameter.
23. Volume-Interpolation in `toolhub.yaml` auf strikt erforderliche Base-Variable umgestellt (`${TOOLHUB_BASEDIR:?TOOLHUB_BASEDIR is required}`), damit fehlende Portainer-Env-Variablen sofort als Konfigurationsfehler auffallen.
24. Alle Fallback-Interpolationen in `toolhub.yaml` entfernt: Variablen werden jetzt ausschließlich als `${VAR}` referenziert (keine `:-`/`:?`-Syntax), damit die Werte vollständig aus `toolhub.env` bzw. Portainer-Env stammen.
25. n8n-only OpenAI-Strategie im Stack umgesetzt: `OPENAI_*`-Variablen aus `toolhub.yaml` und `toolhub.env` entfernt, damit Toolhub keine OpenAI-Credentials erwartet und API-Anbindung vollständig in n8n verbleibt.
26. OpenAI-Integration vollständig aus Toolhub-Codebasis entfernt: `scripts/transcript.py` auf lokalen Whisper-Backend-only reduziert, zugehörige OpenAI-Dokumentation in `README.md`, `AGENTS.md` und `docs/features.md` bereinigt sowie veraltete Stack-Dateien `stack.yml`/`stack.env` durch `toolhub.yaml`/`toolhub.env` ersetzt.
27. README auf aktuellen Code-/Deployment-Stand harmonisiert: Referenzen auf `stack.yml`/`stack.env` und `/volume1` entfernt, Portainer-Flow auf `toolhub.yaml`/`toolhub.env` mit strikter Variablenauflösung dokumentiert, Variablenmatrix bereinigt und Feature-Contract (`docs/features.md`) als primäre Funktionsreferenz verlinkt.
28. Troubleshooting-Doku für Portainer-Deploy-Failures erweitert (`README.md`): konkreter Hinweis auf fehlende Bind-Mount-Verzeichnisse (inkl. `mkdir -p`-Snippet) sowie Netzwerkanforderung bei statischer IP (`ipv4_address` benötigt externes Netzwerk mit konfiguriertem Subnet).
29. Importierbare n8n-Workflow-Vorlage für den vollständigen Audio-Pfad erstellt (`docs/workflows/n8n_ios_audio_toolhub_whisper_notion.json`): iOS-Webhook-Ingress, Write-to-`/shared`, Toolhub-Split via HTTP, Chunk-Transkription via OpenAI, JSON-basierte GPT-Anreicherung und Notion-Persistenz in einer Zeile pro Aufnahme.
30. Workflow-Dokumentation ergänzt (`docs/n8n_audio_pipeline.md`): Voraussetzungen, benötigte Env-Variablen, Import-/Aktivierungsschritte, Webhook-Contract, Notion-Property-Mapping und Validierungscheckliste.
31. README um direkte Referenzen auf die neue n8n-Workflow-Implementierung erweitert (`README.md`), damit der End-to-End-Flow im Haupt-Entry-Point auffindbar und nutzbar ist.
32. OpenAI-Enrichment-Node im n8n-Workflow auf festen Prompt-Call umgestellt (`gpt-5.2` + `prompt.id=pmpt_698c7fb03f9881969e81d41faa8b70780705e6b67ad926b7`, Input aus `$json.transcript`), inklusive Dokumentationsanpassung in `docs/n8n_audio_pipeline.md`.
33. n8n-Workflow auf native App-Nodes aus der aktuellen n8n-Doku umgestellt: OpenAI-Transkription (`resource=audio`, `operation=transcribe`) und OpenAI-Response (`resource=text`, `operation=response`, Prompt-ID gesetzt) statt direkter HTTP-Calls.
34. Notion-Persistenz auf nativen Notion-Node (`resource=databasePage`, `operation=create`) migriert und Feld-Mapping als `propertiesUi` im Node hinterlegt; Dokumentation auf Credentials-basiertes Setup (`openAiApi`, `notionApi`) aktualisiert.
35. Neuer multipart-basierter Webhook-Endpoint `POST /audio-ingest-split` in `scripts/webhook.py` finalisiert und auf stabile Manifest-Response ausgerichtet (`recordingId`, `jobId`, `ingest`, `meta`, `chunks[]`), inklusive Hilfsfunktionen für Dateiname-/RecordingId-/Meta-Normalisierung.
36. Neuer Binary-Download-Endpoint `GET /audio-chunk/<job_id>/<filename>` in `scripts/webhook.py` finalisiert (Job-ID-/Filename-Validierung, Extension-Whitelist, Traversal-Schutz, MIME-Typ-Ausgabe); `/audio-split` unverändert für Backward Compatibility belassen.
37. Workflow-Vorlage `docs/workflows/n8n_ios_audio_toolhub_whisper_notion.json` vollständig auf 0-JS-Nodes umgebaut: Webhook -> `audio-ingest-split` -> SplitOut -> Chunk-Download -> OpenAI Transcribe -> Sort/Aggregate -> OpenAI Enrichment (`gpt-5.2`, `promptId=pmpt_698c7fb03f9881969e81d41faa8b70780705e6b67ad926b7`) -> Notion -> Respond.
38. Audio-Dokumentation auf neuen Ingest-/Chunk-Contract aktualisiert (`docs/audio-split.md`), inklusive Request/Response-Schema, Curl-Beispiele und einheitlichem Fehlervertrag (`error`, `message`, optional `detail`).
39. Feature-Matrix und Webhook-Contracts in `docs/features.md` auf neue Endpoints (`/audio-ingest-split`, `/audio-chunk/...`) erweitert und als empfohlener n8n-Pfad dokumentiert.
40. README und n8n-Workflow-Doku auf vereinfachten Ingest-Flow aktualisiert (`README.md`, `docs/n8n_audio_pipeline.md`) und Implementierung syntaktisch verifiziert (`python3 -m py_compile scripts/webhook.py`, `jq empty docs/workflows/n8n_ios_audio_toolhub_whisper_notion.json`).
41. Zweite n8n-Workflow-Variante mit geringer Expression-Komplexität erstellt (`docs/workflows/n8n_ios_audio_toolhub_whisper_notion_low_expression.json`): weiterhin 0 JS-Code-Nodes, aber kleinteiligere Set-/Merge-Schritte für einfacheres Debugging und Wartung.
42. Neuer n8n-primärer Split-Endpoint `POST /n8n_audio_split` in `scripts/webhook.py` ergänzt und auf denselben ingest+split Manifest-Contract wie Upload-Endpunkte ausgerichtet; bestehende Endpoints (`/audio-ingest-split`, `/audio-split`, `/audio-chunk`) unverändert kompatibel gehalten.
43. `/run` um n8n-Aliasauflösung erweitert (`n8n_audio_cleanup`, `n8n_audio_transcript_local`, `n8n_wol`, `n8n_docx_render`, `n8n_docx_template_fill`, optional `n8n_audio_split_compat`) inklusive Logging von `requested_tool` und `resolved_tool`.
44. Silence-Split-Algorithmus in `scripts/audio-split.sh` angepasst: bei mehreren Stille-Treffern im Suchfenster wird jetzt der nächste Treffer vor der Boundary verwendet (nearest-before-boundary) statt des ersten Treffers.
45. Öffentliches Community-Node-Paket erstellt (`integrations/n8n-nodes-toolhub`): Paket-Metadaten, Build-Konfiguration, Credential `Toolhub API`, gemeinsamer API-Helper und sieben produktive Nodes (`Toolhub Audio Split`, `Toolhub Audio Split Compat`, `Toolhub Audio Transcript Local`, `Toolhub Audio Cleanup`, `Toolhub WOL`, `Toolhub DOCX Render`, `Toolhub DOCX Template Fill`).
46. Community-Node-Dokumentation und Beispiele ergänzt (`docs/n8n_community_nodes_toolhub.md`, `docs/workflows/n8n_toolhub_community_audio_split.json`, `docs/workflows/n8n_toolhub_community_cleanup.json`, `docs/workflows/n8n_toolhub_community_docx_render.json`) sowie Hauptdokumentation auf neue n8n-Audio- und Alias-Contracts aktualisiert (`docs/features.md`, `docs/audio-split.md`, `README.md`, `docs/n8n_audio_pipeline.md`).
47. Stack-Struktur auf Single-Root-Volume vereinfacht: `toolhub.yaml` nutzt jetzt nur noch `${TOOLHUB_PROJECT_DIR}:/workspace`, `start.sh` erstellt/verwaltet die Unterstruktur und verlinkt Legacy-Pfade (`/scripts`, `/shared`, `/logs`, `/data`, `/templates`, `/output`) automatisch; `toolhub.env` und `README.md` auf das neue Layout aktualisiert.
48. Release-Hotfix für GHCR-Workflow: Build-Fehler aufgrund fehlendem `logs/`-Ordner im frischen Git-Checkout identifiziert (Check-Run-Annotation) und behoben, indem `Dockerfile` kein `COPY logs/` mehr ausführt und `start.sh` Bootstrap-Logs nur optional kopiert, wenn `/bootstrap/logs` existiert.
49. GHCR-/GitHub-Package-Diagnose in `README.md` ergänzt: korrekter API-Namespace für dieses Setup ist `/users/wirrockendigital/packages/container/toolhub` (statt `/orgs/...`), inklusive `gh auth` Scope-Check und Re-Login mit `read:packages`/`write:packages`.
